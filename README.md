# Goodini
## Описание:
Этот репозиторий содержит решение тестового задания по созданию простейшего Web-приложения. Задание включает в себя создание модели "User" с полями "Id", "FirstName", "LastName" и "Email". Также требуется реализовать CRUD операции с этой моделью через контроллер "UserController" и использование репозитория "UserRepository" для доступа к данным.

## Model
Модель User:
```c#
public class UserEntity
{
    public int Id { get; set; } // PK
    public required string FirstName { get; set; } // PROPERTY && REQUIRED
    public required string LastName { get; set; } // PROPERTY && REQUIRED
    public required string Email { get; set; } // INDEX && UNIQUE
}
```
  
## Controller:
* **GET api/users:** Получить список всех пользователей.
* **GET api/users/{id}:** Получить пользователя по Id.
* **POST api/users:** Создать нового пользователя.
* **PUT api/users/{id}:** Обновить информацию о пользователе.
* **DELETE api/users/{id}:** Удалить пользователя.

## Infrastructure
В данном репозитории для работы с базой данных был использован Entity Framework Core (EF Core) и паттерн репозиторий.

### Паттерн Репозиторий:
Паттерн Репозиторий был использован для абстрагирования доступа к данным модели "User". Репозиторий предоставляет унифицированный интерфейс для выполнения операций CRUD, что делает код контроллера более чистым и поддерживаемым.

### Алтернативное решение:
В данном случае, репозиторий был реализован в контексте тестового задания. Однако, при работе в команде с большим числом разработчиков, решение использовать репозиторий мне не симпатизирует, так как вызывает некоторые проблемы. В частности, DbContext уже представляет собой Unit of Work, и добавление еще одного слоя абстракции (репозитория) может создавать дополнительную сложность и увеличивать избыточность кода.
При работе в команде более трех человек может быть разумным рассмотреть альтернативные подходы, такие как CQRS (Command Query Responsibility Segregation). В CQRS, отделение команд (мутаций) от запросов может уменьшить сложность кода и улучшить масштабируемость. Вместо использования репозитория как Unit of Work, разделение операций чтения и записи позволяет более гибко управлять данными в приложении.
